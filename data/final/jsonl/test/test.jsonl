{"code": "<s> from django . utils . translation import ugettext_lazy as _ <EOL> from horizon import tabs <EOL> class NetworkProfileTab ( tabs . Tab ) : <EOL> name = _ ( \"<STR_LIT>\" ) <EOL> slug = \"<STR_LIT>\" <EOL> template_name = '<STR_LIT>' <EOL> def get_context_data ( self , request ) : <EOL> return None <EOL> class PolicyProfileTab ( tabs . Tab ) : <EOL> name = _ ( \"<STR_LIT>\" ) <EOL> slug = \"<STR_LIT>\" <EOL> template_name = '<STR_LIT>' <EOL> preload = False <EOL> class IndexTabs ( tabs . TabGroup ) : <EOL> slug = \"<STR_LIT>\" <EOL> tabs = ( NetworkProfileTab , PolicyProfileTab ) </s>\n"}
{"code": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import weakref <EOL> from eventlet import corolocal <EOL> class WeakLocal ( corolocal . local ) : <EOL> def __getattribute__ ( self , attr ) : <EOL> rval = corolocal . local . __getattribute__ ( self , attr ) <EOL> if rval : <EOL> rval = rval ( ) <EOL> return rval <EOL> def __setattr__ ( self , attr , value ) : <EOL> value = weakref . ref ( value ) <EOL> return corolocal . local . __setattr__ ( self , attr , value ) <EOL> store = WeakLocal ( ) <EOL> weak_store = WeakLocal ( ) <EOL> strong_store = corolocal . local </s>\n"}
{"code": "<s> import eventlet <EOL> eventlet . monkey_patch ( ) <EOL> import contextlib <EOL> import sys <EOL> from oslo . config import cfg <EOL> from openstack_dashboard . openstack . common import log as logging <EOL> from openstack_dashboard . openstack . common import rpc <EOL> from openstack_dashboard . openstack . common . rpc import impl_zmq <EOL> CONF = cfg . CONF <EOL> CONF . register_opts ( rpc . rpc_opts ) <EOL> CONF . register_opts ( impl_zmq . zmq_opts ) <EOL> def main ( ) : <EOL> CONF ( sys . argv [ <NUM_LIT:1> : ] , project = '<STR_LIT>' ) <EOL> logging . setup ( \"<STR_LIT>\" ) <EOL> with contextlib . closing ( impl_zmq . ZmqProxy ( CONF ) ) as reactor : <EOL> reactor . consume_in_thread ( ) <EOL> reactor . wait ( ) </s>\n"}
{"code": "<s> from openstack_dashboard import api <EOL> from openstack_dashboard . test import helpers as test <EOL> from neutronclient . v2_0 import client <EOL> neutronclient = client . Client <EOL> class VPNaasApiTests ( test . APITestCase ) : <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservice_create ( self ) : <EOL> vpnservice1 = self . api_vpnservices . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : vpnservice1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : vpnservice1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : vpnservice1 [ '<STR_LIT>' ] <EOL> } <EOL> vpnservice = { '<STR_LIT>' : self . api_vpnservices . first ( ) } <EOL> neutronclient . create_vpnservice ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( vpnservice ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservice_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . VPNService ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservices_get ( self ) : <EOL> vpnservices = { '<STR_LIT>' : self . vpnservices . list ( ) } <EOL> vpnservices_dict = { '<STR_LIT>' : self . api_vpnservices . list ( ) } <EOL> neutronclient . list_vpnservices ( ) . AndReturn ( vpnservices_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservices_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , vpnservices [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . VPNService ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_vpnservice_get ( self ) : <EOL> vpnservice1 = self . api_vpnservices . first ( ) <EOL> vpnservice = { '<STR_LIT>' : vpnservice1 } <EOL> neutronclient . show_vpnservice ( <EOL> vpnservice [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( vpnservice ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . vpnservice_get ( self . request , <EOL> vpnservice [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . VPNService ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicy_create ( self ) : <EOL> ikepolicy1 = self . api_ikepolicies . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ikepolicy1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ikepolicy1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ikepolicy1 [ '<STR_LIT>' ] <EOL> } <EOL> ikepolicy = { '<STR_LIT>' : self . api_ikepolicies . first ( ) } <EOL> neutronclient . create_ikepolicy ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( ikepolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IKEPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicies_get ( self ) : <EOL> ikepolicies = { '<STR_LIT>' : self . ikepolicies . list ( ) } <EOL> ikepolicies_dict = { '<STR_LIT>' : self . api_ikepolicies . list ( ) } <EOL> neutronclient . list_ikepolicies ( ) . AndReturn ( ikepolicies_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicies_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , ikepolicies [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IKEPolicy ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ikepolicy_get ( self ) : <EOL> ikepolicy1 = self . api_ikepolicies . first ( ) <EOL> ikepolicy = { '<STR_LIT>' : ikepolicy1 } <EOL> neutronclient . show_ikepolicy ( <EOL> ikepolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( ikepolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ikepolicy_get ( self . request , <EOL> ikepolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IKEPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicy_create ( self ) : <EOL> ipsecpolicy1 = self . api_ipsecpolicies . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ipsecpolicy1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ipsecpolicy1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecpolicy1 [ '<STR_LIT>' ] <EOL> } <EOL> ipsecpolicy = { '<STR_LIT>' : self . api_ipsecpolicies . first ( ) } <EOL> neutronclient . create_ipsecpolicy ( <EOL> { '<STR_LIT>' : form_data } ) . AndReturn ( ipsecpolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicy_create ( self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicies_get ( self ) : <EOL> ipsecpolicies = { '<STR_LIT>' : self . ipsecpolicies . list ( ) } <EOL> ipsecpolicies_dict = { '<STR_LIT>' : self . api_ipsecpolicies . list ( ) } <EOL> neutronclient . list_ipsecpolicies ( ) . AndReturn ( ipsecpolicies_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicies_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , ipsecpolicies [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IPSecPolicy ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecpolicy_get ( self ) : <EOL> ipsecpolicy1 = self . api_ipsecpolicies . first ( ) <EOL> ipsecpolicy = { '<STR_LIT>' : ipsecpolicy1 } <EOL> neutronclient . show_ipsecpolicy ( <EOL> ipsecpolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( ipsecpolicy ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecpolicy_get ( self . request , <EOL> ipsecpolicy [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecPolicy ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnection_create ( self ) : <EOL> ipsecsiteconnection1 = self . api_ipsecsiteconnections . first ( ) <EOL> form_data = { <EOL> '<STR_LIT:name>' : ipsecsiteconnection1 [ '<STR_LIT:name>' ] , <EOL> '<STR_LIT:description>' : ipsecsiteconnection1 [ '<STR_LIT:description>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ipsecsiteconnection1 [ '<STR_LIT>' ] <EOL> } <EOL> ipsecsiteconnection = { '<STR_LIT>' : <EOL> self . api_ipsecsiteconnections . first ( ) } <EOL> neutronclient . create_ipsec_site_connection ( <EOL> { '<STR_LIT>' : <EOL> form_data } ) . AndReturn ( ipsecsiteconnection ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnection_create ( <EOL> self . request , ** form_data ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecSiteConnection ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnections_get ( self ) : <EOL> ipsecsiteconnections = { <EOL> '<STR_LIT>' : self . ipsecsiteconnections . list ( ) } <EOL> ipsecsiteconnections_dict = { <EOL> '<STR_LIT>' : self . api_ipsecsiteconnections . list ( ) } <EOL> neutronclient . list_ipsec_site_connections ( ) . AndReturn ( <EOL> ipsecsiteconnections_dict ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnections_get ( self . request ) <EOL> for ( v , d ) in zip ( ret_val , <EOL> ipsecsiteconnections [ '<STR_LIT>' ] ) : <EOL> self . assertIsInstance ( v , api . vpn . IPSecSiteConnection ) <EOL> self . assertTrue ( v . name , d . name ) <EOL> self . assertTrue ( v . id ) <EOL> @ test . create_stubs ( { neutronclient : ( '<STR_LIT>' , ) } ) <EOL> def test_ipsecsiteconnection_get ( self ) : <EOL> ipsecsiteconnection1 = self . api_ipsecsiteconnections . first ( ) <EOL> ipsecsiteconnection = { '<STR_LIT>' : ipsecsiteconnection1 } <EOL> neutronclient . show_ipsec_site_connection ( <EOL> ipsecsiteconnection [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) . AndReturn ( <EOL> ipsecsiteconnection ) <EOL> self . mox . ReplayAll ( ) <EOL> ret_val = api . vpn . ipsecsiteconnection_get ( self . request , <EOL> ipsecsiteconnection [ '<STR_LIT>' ] [ '<STR_LIT:id>' ] ) <EOL> self . assertIsInstance ( ret_val , api . vpn . IPSecSiteConnection ) </s>\n"}
{"code": "<s> from horizon import tables <EOL> from openstack_dashboard . usage import base <EOL> class UsageView ( tables . DataTableView ) : <EOL> usage_class = None <EOL> show_terminated = True <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( UsageView , self ) . __init__ ( * args , ** kwargs ) <EOL> if not issubclass ( self . usage_class , base . BaseUsage ) : <EOL> raise AttributeError ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> def get_template_names ( self ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> return \"<STR_LIT:.>\" . join ( ( self . template_name . rsplit ( '<STR_LIT:.>' , <NUM_LIT:1> ) [ <NUM_LIT:0> ] , '<STR_LIT>' ) ) <EOL> return self . template_name <EOL> def get_content_type ( self ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> return \"<STR_LIT>\" <EOL> return \"<STR_LIT>\" <EOL> def get_data ( self ) : <EOL> project_id = self . kwargs . get ( '<STR_LIT>' , self . request . user . tenant_id ) <EOL> self . usage = self . usage_class ( self . request , project_id ) <EOL> self . usage . summarize ( * self . usage . get_date_range ( ) ) <EOL> self . usage . get_limits ( ) <EOL> self . kwargs [ '<STR_LIT>' ] = self . usage <EOL> return self . usage . usage_list <EOL> def get_context_data ( self , ** kwargs ) : <EOL> context = super ( UsageView , self ) . get_context_data ( ** kwargs ) <EOL> context [ '<STR_LIT>' ] . kwargs [ '<STR_LIT>' ] = self . usage <EOL> context [ '<STR_LIT>' ] = self . usage . form <EOL> context [ '<STR_LIT>' ] = self . usage <EOL> return context <EOL> def render_to_response ( self , context , ** response_kwargs ) : <EOL> if self . request . GET . get ( '<STR_LIT>' , '<STR_LIT:html>' ) == '<STR_LIT>' : <EOL> render_class = self . csv_response_class <EOL> response_kwargs . setdefault ( \"<STR_LIT:filename>\" , \"<STR_LIT>\" ) <EOL> else : <EOL> render_class = self . response_class <EOL> resp = render_class ( request = self . request , <EOL> template = self . get_template_names ( ) , <EOL> context = context , <EOL> content_type = self . get_content_type ( ) , <EOL> ** response_kwargs ) <EOL> return resp </s>\n"}
{"code": "<s> from enum import IntEnum <EOL> from . component import Component <EOL> from . object import field <EOL> class ReflectionProbeUsage ( IntEnum ) : <EOL> Off = <NUM_LIT:0> <EOL> BlendProbes = <NUM_LIT:1> <EOL> BlendProbesAndSkybox = <NUM_LIT:2> <EOL> Simple = <NUM_LIT:3> <EOL> class ShadowCastingMode ( IntEnum ) : <EOL> Off = <NUM_LIT:0> <EOL> On = <NUM_LIT:1> <EOL> TwoSided = <NUM_LIT:2> <EOL> ShadowsOnly = <NUM_LIT:3> <EOL> class Renderer ( Component ) : <EOL> enabled = field ( \"<STR_LIT>\" , bool ) <EOL> lightmap_index = field ( \"<STR_LIT>\" ) <EOL> materials = field ( \"<STR_LIT>\" ) <EOL> probe_anchor = field ( \"<STR_LIT>\" ) <EOL> receive_shadows = field ( \"<STR_LIT>\" , bool ) <EOL> reflection_probe_usage = field ( \"<STR_LIT>\" , ReflectionProbeUsage ) <EOL> shadow_casting_mode = field ( \"<STR_LIT>\" , ShadowCastingMode ) <EOL> sorting_layer_id = field ( \"<STR_LIT>\" ) <EOL> sorting_order = field ( \"<STR_LIT>\" ) <EOL> use_light_probes = field ( \"<STR_LIT>\" , bool ) <EOL> lightmap_index_dynamic = field ( \"<STR_LIT>\" ) <EOL> lightmap_tiling_offset = field ( \"<STR_LIT>\" ) <EOL> lightmap_tiling_offset_dynamic = field ( \"<STR_LIT>\" ) <EOL> static_batch_root = field ( \"<STR_LIT>\" ) <EOL> subset_indices = field ( \"<STR_LIT>\" ) <EOL> @ property <EOL> def material ( self ) : <EOL> return self . materials [ <NUM_LIT:0> ] <EOL> class ParticleSystemRenderMode ( IntEnum ) : <EOL> Billboard = <NUM_LIT:0> <EOL> Stretch = <NUM_LIT:1> <EOL> HorizontalBillboard = <NUM_LIT:2> <EOL> VerticalBillboard = <NUM_LIT:3> <EOL> Mesh = <NUM_LIT:4> <EOL> class ParticleSystemSortMode ( IntEnum ) : <EOL> None_ = <NUM_LIT:0> <EOL> Distance = <NUM_LIT:1> <EOL> OldestInFront = <NUM_LIT:2> <EOL> YoungestInFront = <NUM_LIT:3> <EOL> class MeshRenderer ( Component ) : <EOL> pass <EOL> class ParticleRenderer ( Renderer ) : <EOL> camera_velocity_scale = field ( \"<STR_LIT>\" ) <EOL> length_scale = field ( \"<STR_LIT>\" ) <EOL> max_particle_size = field ( \"<STR_LIT>\" ) <EOL> velocity_scale = field ( \"<STR_LIT>\" ) <EOL> stretch_particles = field ( \"<STR_LIT>\" ) <EOL> uv_animation = field ( \"<STR_LIT>\" ) <EOL> class ParticleSystemRenderer ( Renderer ) : <EOL> camera_velocity_scale = field ( \"<STR_LIT>\" ) <EOL> length_scale = field ( \"<STR_LIT>\" ) <EOL> max_particle_size = field ( \"<STR_LIT>\" ) <EOL> mesh = field ( \"<STR_LIT>\" ) <EOL> mesh1 = field ( \"<STR_LIT>\" ) <EOL> mesh2 = field ( \"<STR_LIT>\" ) <EOL> mesh3 = field ( \"<STR_LIT>\" ) <EOL> normal_direction = field ( \"<STR_LIT>\" ) <EOL> render_mode = field ( \"<STR_LIT>\" , ParticleSystemRenderMode ) <EOL> sort_mode = field ( \"<STR_LIT>\" , ParticleSystemSortMode ) <EOL> sorting_fudge = field ( \"<STR_LIT>\" ) <EOL> velocity_scale = field ( \"<STR_LIT>\" ) </s>\n"}
{"code": "<s> from ConfigParser import * <EOL> from StringIO import * <EOL> from Log import Log <EOL> import datetime <EOL> class Config : <EOL> @ staticmethod <EOL> def LoadConfig ( ) : <EOL> Config . parser = ConfigParser ( ) <EOL> try : <EOL> sconff = open ( CONFIG_FILE , \"<STR_LIT:r>\" ) <EOL> except : <EOL> Log . warn ( \"<STR_LIT>\" ) <EOL> return <EOL> sconf = StringIO ( ) <EOL> sconf . write ( \"<STR_LIT>\" ) <EOL> sconf . write ( sconff . read ( ) ) <EOL> sconf . seek ( <NUM_LIT:0> ) <EOL> Config . parser . readfp ( sconf ) <EOL> sconff . close ( ) <EOL> sconf . close ( ) <EOL> return <EOL> @ staticmethod <EOL> def GetBoardsFile ( ) : <EOL> return BOARDS_FILE <EOL> @ staticmethod <EOL> def GetInt ( name , defval ) : <EOL> if ( Config . parser . has_option ( '<STR_LIT>' , name ) ) : <EOL> return Config . parser . getint ( '<STR_LIT>' , name ) <EOL> else : <EOL> return defval <EOL> @ staticmethod <EOL> def GetString ( name , defval ) : <EOL> if ( Config . parser . has_option ( '<STR_LIT>' , name ) ) : <EOL> val = Config . parser . get ( '<STR_LIT>' , name ) <EOL> if ( val [ <NUM_LIT:0> ] == '<STR_LIT:\">' and val . endswith ( '<STR_LIT:\">' ) ) : <EOL> val = val [ <NUM_LIT:1> : - <NUM_LIT:1> ] <EOL> return val . decode ( '<STR_LIT>' ) <EOL> else : <EOL> return defval <EOL> BBS_ROOT = '<STR_LIT>' <EOL> BBS_XMPP_CERT_FILE = BBS_ROOT + \"<STR_LIT>\" <EOL> BBS_XMPP_KEY_FILE = BBS_ROOT + \"<STR_LIT>\" <EOL> BOARDS_FILE = BBS_ROOT + '<STR_LIT>' <EOL> STRLEN = <NUM_LIT> <EOL> ARTICLE_TITLE_LEN = <NUM_LIT> <EOL> BM_LEN = <NUM_LIT> <EOL> MAXBOARD = <NUM_LIT> <EOL> CONFIG_FILE = BBS_ROOT + '<STR_LIT>' <EOL> FILENAME_LEN = <NUM_LIT:20> <EOL> OWNER_LEN = <NUM_LIT:30> <EOL> SESSIONID_LEN = <NUM_LIT:32> <EOL> REFRESH_TOKEN_LEN = <NUM_LIT> <EOL> NAMELEN = <NUM_LIT> <EOL> IDLEN = <NUM_LIT:12> <EOL> MD5PASSLEN = <NUM_LIT:16> <EOL> OLDPASSLEN = <NUM_LIT> <EOL> MOBILE_NUMBER_LEN = <NUM_LIT> <EOL> MAXCLUB = <NUM_LIT> <EOL> MAXUSERS = <NUM_LIT> <EOL> MAX_MSG_SIZE = <NUM_LIT> <EOL> MAXFRIENDS = <NUM_LIT> <EOL> MAXMESSAGE = <NUM_LIT:5> <EOL> MAXSIGLINES = <NUM_LIT:6> <EOL> IPLEN = <NUM_LIT:16> <EOL> DEFAULTBOARD = \"<STR_LIT>\" <EOL> BLESS_BOARD = \"<STR_LIT>\" <EOL> QUOTED_LINES = <NUM_LIT:10> <EOL> MAXACTIVE = <NUM_LIT> <EOL> USHM_SIZE = MAXACTIVE + <NUM_LIT:10> <EOL> UTMP_HASHSIZE = USHM_SIZE * <NUM_LIT:4> <EOL> UCACHE_SEMLOCK = <NUM_LIT:0> <EOL> LEN_FRIEND_EXP = <NUM_LIT:15> <EOL> REFRESH_TIME = <NUM_LIT:30> <EOL> USER_TITLE_LEN = <NUM_LIT> <EOL> SESSION_TIMEOUT = datetime . timedelta ( <NUM_LIT:30> ) <EOL> SESSION_TIMEOUT_SECONDS = <NUM_LIT> * <NUM_LIT:30> <EOL> XMPP_IDLE_TIME = <NUM_LIT> <EOL> XMPP_LONG_IDLE_TIME = <NUM_LIT> <EOL> XMPP_UPDATE_TIME_INTERVAL = <NUM_LIT:10> <EOL> XMPP_PING_TIME_INTERVAL = <NUM_LIT> <EOL> PUBLIC_SHMKEY = <NUM_LIT> <EOL> MAX_ATTACHSIZE = <NUM_LIT:20> * <NUM_LIT> * <NUM_LIT> <EOL> BMDEL_DECREASE = True <EOL> SYSMAIL_BOARD = \"<STR_LIT>\" <EOL> ADD_EDITMARK = True <EOL> SEARCH_COUNT_LIMIT = <NUM_LIT:20> <EOL> MAIL_SIZE_LIMIT = - <NUM_LIT:1> <EOL> SEC_DELETED_OLDHOME = <NUM_LIT> * <NUM_LIT> * <NUM_LIT:3> <EOL> SELF_INTRO_MAX_LEN = <NUM_LIT> </s>\n"}